# MPT_report

# 实验名称
MPT_report

# 实验简介
MPT学习报告

# 实验完成人
王晖

学号：202100141110

git账户名称：jokerduck
# 前言

## 前缀树
前缀树（又称字典树），用于保存关联数组，其键（key）的内容通常为字符串。前缀树节点在树中的位置是由其键的内容所决定的，即前缀树的key值被编码在根节点到该节点的路径中。

如下图所示，图中共有6个叶子节点，其key的值分别为（1）tc（2）tea（3）ted（4）ten（5）Ab（6）il

![image](https://user-images.githubusercontent.com/105578152/181406571-3a835e02-2622-42e0-b6f7-f2e759bcc972.png)

__优势__

1、相比于哈希表，使用前缀树来进行查询拥有共同前缀key的数据时十分高效，例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)；然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。

2、相比于哈希表，前缀树不会存在哈希冲突的问题。

__劣势__

1、直接查找效率低下

前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。且一次查找会有m次I/O开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。

2、可能造成空间浪费

当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。

## Merkle Tree
### 特点
1、默克尔树是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；

2、默克尔树叶子节点的value是数据项的内容，或者是数据项的哈希值；

3、非叶子节点的value根据其孩子节点的信息，然后按照Hash算法计算而得出的。

### 原理
在比特币网络中，merkle树是自底向上构建的，如下图所示：

![image](https://user-images.githubusercontent.com/105578152/181407089-4306e26a-0d3d-48ca-a2de-5e88f7d76f47.png)

将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。若两棵树的根哈希一致，则这两棵树的结构、节点的内容必然相同。

__优势__

1、快速重哈希

默克尔树的特点之一就是当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。

2、轻节点扩展

采用默克尔树，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。

__劣势__

存储空间开销大

# MPT
## 概述
Merkle Patricia Tree（又称Merkle Patricia Trie）是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。

MPT树有以下几个作用：

1、存储任意长度的key-value键值对数据；

2、提供了一种快速计算所维护数据集哈希标识的机制；

3、提供了快速状态回滚的机制；

4、提供了一种称为默克尔证明的证明方法，进行轻节点的扩展，实现简单支付验证。

## 节点分类
MPT树中，树节点可以分为以下几类：空节点、分支节点、叶子节点、扩展节点

### 空节点
空节点用来表示空串。

### 分支节点

分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点

与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换，将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，key’的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，但是在一定程度上增加了树高。

分支节点的孩子列表中，最后一个元素是用来存储自身的内容。

此外，每个分支节点会有一个附带的字段nodeFlag，记录了一些辅助数据：

（1）节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；

（2）脏标志：当一个节点被修改时，该标志位被置为1；

（3）诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多。

### 叶子节点&&扩展节点

关键的字段为：

（1）Key：用来存储属于该节点范围的key，这是MPT树实现树高压缩的关键；

（2）Val：用来存储该节点的内容；

如之前所提及的，前缀树中会出现严重的存储空间浪费的情况，如下图：

![image](https://user-images.githubusercontent.com/105578152/181411332-0cdf8f00-fccf-4545-b301-9a20dfa054e4.png)


针对这种情况，MPT树对此进行了优化：当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把剩余的Key存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。

![image](https://user-images.githubusercontent.com/105578152/181411355-b722d273-9709-4e59-a584-434a8fd3eb4e.png)

例如图中我们将红线所圈的节点称为node1, 将紫色线所圈的节点称为node2。node1与node2共享路径前缀t，但是node1在插入时，树中没有与oast有共同前缀的路径，因此node1的key为oast，实现了编码路径的压缩。

这种做法可以提高节点的查找效率，避免过多的磁盘访问，并且减少存储空间浪费，避免存储无用的节点。

## 安全的MPT
以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：

（1）查询一个节点可能会需要许多次IO读取，效率低下；

（2）系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降；

（3）所有的key其实是一种明文的形式进行存储。

为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是(sha3(key), value)

__优势__

1、传入MPT接口的key是固定长度的（32字节），可以避免出现树中出现长度很长的路径；

__劣势__

1、每次树操作需要增加一次哈希计算；

2、需要在数据库中存储额外的sha3(key)与key之间的对应关系。

## 基本操作
### Get
__一次Get操作的过程为：__

将需要查找Key的Raw编码转换成Hex编码，得到的内容称之为搜索路径，从根节点开始搜寻与搜索路径内容一致的路径；

1、若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。

2、若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。

3、若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。

4、若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，将剩余的搜索路径作为参数递归地调用查找函数。

![image](https://user-images.githubusercontent.com/105578152/181409519-c8fa35a8-994c-4cab-8e12-0debcf126060.png)

### Insert
插入操作也是基于查找过程完成的，一个插入过程为：

1、首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；

2、若该Node为分支节点：

（1）剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中；

（2）剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；

3、若该节点为叶子／扩展节点：

（1）剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；

（2）剩余的搜索路径与当前节点的key不完全一致，则将叶子／扩展节点的孩子节点替换成分支节点，将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）；

4、若插入成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在。
![image](https://user-images.githubusercontent.com/105578152/181409689-d84ce053-f085-4c40-a6b0-9063e21a6714.png)

### Delete
删除操作与插入操作类似，都需要借助查找过程完成，一次删除过程为：

1、找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node；

2、若Node为叶子／扩展节点：

（1）若剩余的搜索路径与node的Key完全一致，则将整个node删除；

（2）若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；

（3）若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；

3、若Node为分支节点：

（1） 删除孩子列表中相应下标标志的节点；

（2） 删除结束，若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子／扩展节点；

4、若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在。
![image](https://user-images.githubusercontent.com/105578152/181409812-d5c731c8-4b04-49fa-a599-142dc536f454.png)

### Commit
Commit函数提供将内存中的MPT数据持久化到数据库的功能。在第一章中我们提到的MPT具有快速计算所维护数据集哈希标识以快速状态回滚的能力，也都是在该函数中实现的。

在commit完成后，所有变脏的树节点会重新进行哈希计算，并且将新内容写入数据库；最终新的根节点哈希将被作为MPT的最新状态被返回。

一次MPT树提交是一个递归调用的过程，在介绍MPT提交过程之前，我们首先介绍单个节点是如何进行哈希计算和存储的。

![image](https://user-images.githubusercontent.com/105578152/181409877-4de9e752-fa46-4c1d-81c7-4fea86719ec2.png)

# 轻节点扩展
## 轻节点
在以太坊或比特币中，一个参与共识的全节点通常会维护整个区块链的数据，每个区块中的区块头信息，所有的交易，回执信息等。由于区块链的不可篡改性，这将导致随着时间的增加，整个区块链的数据体量会非常庞大。运行在个人PC或者移动终端的可能性显得微乎其微。为了解决这个问题，一种轻量级的，只存储区块头部信息的节点被提出。这种节点只需要维护链中所有的区块头信息（一个区块头的大小通常为几十个字节，普通的移动终端设备完全能够承受出）。

在公链的环境下，仅仅通过本地所维护的区块头信息，轻节点就能够证明某一笔交易是否存在与区块链中；某一个账户是否存在与区块链中，其余额是多少等功能。

## 默克尔证明
默克尔证明指一个轻节点向一个全节点发起一次证明请求，询问全节点完整的默克尔树中，是否存在一个指定的节点；全节点向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证存在性。

## 默克尔证明过程
如有棵如下图所示的merkle树，如果某个轻节点想要验证9Dog:64这个树节点是否存在与默克尔树中，只需要向全节点发送该请求，全节点会返回一个1FXq:18, ec20,
8f74的一个路径（默克尔路径，如图2黄色框所表示的）。得到路径之后，轻节点利用9Dog:64与1FXq:18求哈希，在与ec20求哈希，最后与8f74求哈希，得到的结果与本地维护的根哈希相比，是否相等。
![image](https://user-images.githubusercontent.com/105578152/181410022-39131628-624c-4b8e-a2c0-bd187c9f65fb.png)

## 默克尔证明安全性
（1）若全节点返回的是一条恶意的路径？

试图为一个不存在于区块链中的节点伪造一条合法的merkle路径，使得最终的计算结果与区块头中的默克尔根哈希相同。由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。

（2）为什么不直接向全节点请求该节点是否存在于区块链中？

由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的默克尔路径，与代验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。

## 简单支付验证
在以太坊中，利用默克尔证明在轻节点中实现简单支付验证，即在无需维护具体交易信息的前提下，证明某一笔交易是否存在于区块链中。

# 参考链接
【1】CSDN：MPT详解：

https://blog.csdn.net/qq_40713201/article/details/124486307?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165897398016782390545065%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165897398016782390545065&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124486307-null-null.142^v35^experiment_2_v1,185^v2^control&utm_term=MPT&spm=1018.2226.3001.4187
